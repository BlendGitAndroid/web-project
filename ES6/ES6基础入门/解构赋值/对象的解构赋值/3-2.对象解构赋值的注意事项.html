<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>对象解构赋值的注意事项</title>
  </head>
  <body>
    <script>
      // 1.默认值的生效条件
      // 对象的属性值严格等于 undefined 时，对应的默认值才会生效
      // const { username = 'ZhangSan', age = 0 } = { username: 'alex' };
      // console.log(username, age);

      // 2.默认值表达式
      // 如果默认值是表达式，默认值表达式是惰性求值的，即只有在用到的时候才会求值

      // 3.将一个已经声明的变量用于解构赋值
      // let { x:x } = { x: 1 };
      // 这是上面的简单写法
      let { x } = { x: 1 };
      console.log(x);

      console.log("----------------------------------------")

      let xx = 2;
      // 这里需要用圆括号，原因是如果将一个已经声明的变量用于对象的解构赋值，整个赋值需在圆括号中进行，叫浏览器不会将大括号解析为代码块
      // 而const {} = {}这样的解构，const后面的{}会被解析为对象
      // ({ xxx:xx } = { xxx: 1 });
      // 为什么会被解析为代码块呢？因为大括号{}在 JavaScript 中有两种含义，一种是对象字面量，一种是代码块。
      // 当大括号出现在赋值语句的左侧时，JavaScript 引擎会将其解析为代码块，而不是对象字面量，这就是为什么 ({}) = {} 会报错的原因。
      // 为了解决这个问题，我们可以在赋值语句的左侧加上圆括号，这样大括号就会被解析为对象字面量，而不是代码块。
      ({ xx } = { xx: 1 }); // 用圆括号括起来，就不会被解析为代码块。
      // ({ xx:xx } = { xx: 1 });
      // [x] = [1];
      console.log(xx);

      // 4.可以取到继承的属性
      // const { a = 1} = {};

      const { toString } = {};
      // console.log(toString);
      // Object.prototype
      // console.log(Object.prototype);
      console.log({});
    </script>
  </body>
</html>
